# Cursor 用プロンプト：直感的に操作できる家系図作成 Web アプリ（Vercel + Neon/Postgres）

あなたは**シニアフルスタックエンジニア兼UI/UXデザイナー**です。以下の仕様に従い、**ゼロから動く家系図 Web アプリ**を実装してください。`pnpm dev`で起動し、トップページから**家系図の作成→編集→自動整列→CSV/JSON エクスポート→印刷/PDF**まで一通り可能な状態にします。**デプロイは Vercel**、\*\*DB は Vercel の Neon（Postgres）\*\*を使います。

---

## ゴール / 受け入れ基準

* 直感的なドラッグ&ドロップ操作で家系図（人物ノード／親子エッジ／配偶者エッジ）を編集できる。
* **React Flow** 上で\*\*自動整列（縦は世代、横は兄弟）\*\*がワンクリックでできる。
* **CRUD**：人物/親子関係/配偶者関係を作成・編集・削除できる。
* **検索・フィルタ**：名前検索、存命/故人など簡易フィルタ。
* **エクスポート**：

  * CSV（people.csv, relationships.csv, partnerships.csv）
  * JSON（ツリー全体のバックアップ）
* **インポート**（最小）：JSON インポートで状態復元。
* **印刷/PDF**：ブラウザ印刷で A4 横に最適化されたスタイルを適用。
* サンプルデータの「ワンクリック投入」あり。
* Vercel へワンクリックでデプロイできる（環境変数を設定するだけ）。

---

## 技術スタック

* **Next.js 14 (App Router) + TypeScript**
* **UI**: Tailwind CSS + **shadcn/ui**（必要最低限のコンポーネント）
* **グラフ**: **React Flow** + **elkjs**（もしくは dagre）で自動レイアウト
* **状態管理**: **Zustand**（Undo/Redo 対応）
* **バリデーション/フォーム**: Zod + React Hook Form
* **DB/ORM**: **Neon(Postgres)** + **Drizzle ORM**（HTTP ドライバ：`drizzle-orm/neon-http` + `@neondatabase/serverless`）
* **マイグレーション**: drizzle-kit
* **日付**: date-fns
* **CSV**: Papa Parse（生成のみでOK）

> Prisma ではなく Drizzle を採用。Vercel の Serverless 環境 + Neon の HTTP 接続に最適化。

---

## 実装ステップ（Cursor による自動実行を想定）

### 1) プロジェクト初期化

1. `pnpm create next-app@latest kakeizu-flow --ts --eslint --tailwind --app --src-dir --import-alias "@/*"`
2. `cd kakeizu-flow && pnpm i`
3. 追加インストール：

   ```bash
   pnpm add reactflow elkjs zustand zod react-hook-form lucide-react class-variance-authority tailwind-merge date-fns
   pnpm add papaparse
   pnpm add drizzle-orm @neondatabase/serverless
   pnpm add -D drizzle-kit dotenv
   ```

### 2) Tailwind & shadcn/ui セットアップ

* shadcn の初期設定と、以下を追加：Button, Input, Dialog, Sheet, DropdownMenu, Label, Select, Separator, Badge, Card, Tabs, Toaster（任意）。
* **レイアウト**：左にツリーと操作ツールバー、右に**エディタサイドパネル**（人物詳細フォーム）という 2 カラム基本構成。

### 3) DB/Drizzle セットアップ

* ルートに `drizzle.config.ts` を作成。
* `.env.local` に **NEON\_DATABASE\_URL** を定義（例）：

  ```env
  NEON_DATABASE_URL=postgresql://USER:PASSWORD@HOST/DB?sslmode=require
  ```
* `src/server/db/schema.ts` を作成し、以下のテーブル定義：

  ```ts
  // drizzle-orm/postgres 用。neon-http ドライバで接続
  import { pgTable, serial, varchar, timestamp, integer, boolean, date, index, uniqueIndex } from "drizzle-orm/pg-core";

  export const trees = pgTable("trees", {
    id: serial("id").primaryKey(),
    name: varchar("name", { length: 120 }).notNull(),
    description: varchar("description", { length: 500 }),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
  });

  export const people = pgTable("people", {
    id: serial("id").primaryKey(),
    treeId: integer("tree_id").notNull(),
    firstName: varchar("first_name", { length: 80 }).notNull(),
    lastName: varchar("last_name", { length: 80 }),
    sex: varchar("sex", { length: 10 }), // male|female|other|unknown
    birthDate: date("birth_date"),
    deathDate: date("death_date"),
    isDeceased: boolean("is_deceased").default(false).notNull(),
    email: varchar("email", { length: 160 }),
    phone: varchar("phone", { length: 40 }),
    address: varchar("address", { length: 240 }),
    city: varchar("city", { length: 120 }),
    prefecture: varchar("prefecture", { length: 120 }),
    country: varchar("country", { length: 120 }),
    lat: varchar("lat", { length: 32 }),
    lng: varchar("lng", { length: 32 }),
    note: varchar("note", { length: 1000 }),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
  }, (t) => ({
    treeIdx: index("people_tree_idx").on(t.treeId),
  }));

  // 親子関係（有向：parent -> child）
  export const relationships = pgTable("relationships", {
    id: serial("id").primaryKey(),
    treeId: integer("tree_id").notNull(),
    parentId: integer("parent_id").notNull(),
    childId: integer("child_id").notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  }, (t) => ({
    uniqueRel: uniqueIndex("uq_parent_child").on(t.treeId, t.parentId, t.childId),
  }));

  // 配偶者/パートナー関係（無向扱い。小さい id を A 側に揃える）
  export const partnerships = pgTable("partnerships", {
    id: serial("id").primaryKey(),
    treeId: integer("tree_id").notNull(),
    partnerAId: integer("partner_a_id").notNull(),
    partnerBId: integer("partner_b_id").notNull(),
    startDate: date("start_date"),
    endDate: date("end_date"),
    type: varchar("type", { length: 24 }).default("marriage").notNull(), // marriage|partner
    createdAt: timestamp("created_at").defaultNow().notNull(),
  }, (t) => ({
    uniquePair: uniqueIndex("uq_partner_pair").on(t.treeId, t.partnerAId, t.partnerBId),
  }));
  ```
* `src/server/db/client.ts` を作成（Neon HTTP クライアント + Drizzle）：

  ```ts
  import { drizzle } from "drizzle-orm/neon-http";
  import { neon } from "@neondatabase/serverless";

  const sql = neon(process.env.NEON_DATABASE_URL!);
  export const db = drizzle(sql);
  ```
* `drizzle.config.ts`（マイグレーション設定）：

  ```ts
  import type { Config } from "drizzle-kit";
  import "dotenv/config";

  export default {
    schema: "./src/server/db/schema.ts",
    out: "./drizzle",
    driver: "pg",
    dbCredentials: { connectionString: process.env.NEON_DATABASE_URL! },
  } satisfies Config;
  ```
* `package.json` にスクリプト：

  ```json
  {
    "scripts": {
      "dev": "next dev",
      "build": "next build",
      "start": "next start",
      "drizzle:push": "drizzle-kit push",
      "drizzle:studio": "drizzle-kit studio"
    }
  }
  ```

### 4) API 設計（App Router /route.ts）

* 名前空間：`/api/trees`, `/api/people`, `/api/relationships`, `/api/partnerships`
* メソッド：`GET`（一覧/詳細）, `POST`, `PUT/PATCH`, `DELETE`
* Zod で入力バリデーション。
* **制約チェック**：

  * 親子ループ（cycle）を禁止（新規追加前に DFS チェック）。
  * 配偶者は自己参照不可。ペアは (minId, maxId) に正規化。

### 5) UI/UX（主要コンポーネント）

* `TreeCanvas`：React Flow キャンバス（パン/ズーム、選択、ドラッグ）
* `Toolbar`：

  * ノード追加（人物追加）
  * 選択ノードを親/子としてエッジ追加
  * 配偶者リンク追加
  * 自動整列（ELK）
  * ズームフィット/リセット
  * エクスポート（CSV/JSON）/インポート（JSON）
  * 印刷ボタン
* `SidePanel`：選択人物の詳細フォーム（React Hook Form + Zod）
* `SearchBox`：名前検索（部分一致）
* `MiniMap`（React Flow のミニマップ）
* **ショートカット**：`Ctrl+Z` Undo / `Ctrl+Shift+Z` Redo / `Del` 削除

### 6) 自動レイアウト（ELK）

* `src/lib/layout.ts` を作成。`elkjs` の layered モードで、世代（親→子）を縦方向に整列、兄弟は横に並べる。
* React Flow のノード/エッジから ELK グラフを生成→座標を反映。

```ts
// 擬似コード例（本実装は Cursor で完全実装）
import ELK, { ElkNode, ElkExtendedEdge } from "elkjs";

export async function layout(nodes, edges) {
  const elk = new ELK();
  const graph: ElkNode = {
    id: "root",
    layoutOptions: {
      "elk.algorithm": "layered",
      "elk.layered.nodePlacement.strategy": "BRANDES_KOEPF",
      "elk.direction": "DOWN",
      "elk.spacing.nodeNode": "40",
      "elk.layered.spacing.nodeNodeBetweenLayers": "60"
    },
    children: nodes.map(n => ({ id: n.id, width: 180, height: 80 })),
    edges: edges.map(e => ({ id: e.id, sources: [e.source], targets: [e.target] } as ElkExtendedEdge))
  };
  const res = await elk.layout(graph);
  // res.children[].x/y を元に React Flow ノードへ座標適用
}
```

### 7) データフロー / 状態

* クライアント側は **Zustand** でローカル編集状態を持ち、確定時に API へ保存（**楽観的更新**）。
* Undo/Redo はローカルの patch 履歴で管理。
* 初回は `trees` にデフォルトツリーを 1 件作成し、その ID で操作。

### 8) エクスポート/インポート/印刷

* **CSV**：Papa Parse で `people`, `relationships`, `partnerships` を個別にダウンロード。
* **JSON**：ツリー全体のスナップショットを 1 ファイルで保存。インポートで上書き復元可能。
* **印刷**：`/print` ルートを用意し、キャンバスを静的描画（ノード・エッジを SVG として出力）→`@media print` で A4 横・余白・色調整。

### 9) サンプルデータ投入

* `src/app/(demo)/demo-seed.ts` を用意して、ボタン一発で祖父母→両親→子の 3 世代例を挿入できる。

### 10) ページ構成

* `/`：ランディング + 「新規ツリー作成/続きから」
* `/editor`：キャンバス + サイドパネル
* `/print`：印刷用ビュー
* **ヘッダー**：プロジェクト名、保存状態表示、エクスポート/印刷への導線

### 11) アクセシビリティ/モバイル

* ノードは 44px 以上のタップターゲット。
* モバイルではサイドパネルを Sheet（スライドイン）で表示。

### 12) 例外処理/トースト

* 失敗時は shadcn の Toaster で通知。

### 13) README 自動生成

* セットアップ、.env 設定、Drizzle マイグレーション手順、Vercel の設定、主要操作の GIF（生成は任意）を記載した README を生成。

---

## 具体的な実装タスク（Cursor への指示）

1. ここまでの仕様でプロジェクトを作成し、必要ファイルをすべて生成。
2. Drizzle のスキーマ/クライアント/マイグレーション設定を作り、`pnpm drizzle:push` で DB を反映できる状態に。
3. API ルート（trees/people/relationships/partnerships）を Zod で保護した CRUD で実装。
4. React Flow キャンバスと ELK レイアウトを組み込み、ツールバーから「自動整列」実行可能に。
5. サイドパネルで人物の追加/編集（氏名、性別、生没日、住所、連絡先、備考）を行い、保存時 API へ反映。
6. 検索ボックスで人物名を部分一致フィルタし、該当ノードを強調表示。
7. エクスポート（CSV/JSON）とインポート（JSON）を実装。
8. 印刷用 `/print` を実装し、A4 横の最適化 CSS を当てる。
9. サンプルデータ投入ボタンを実装。
10. README を生成。

---

## 開発/デプロイ手順（README にも記載）

1. ローカル：

   ```bash
   pnpm i
   cp .env.example .env.local # NEON_DATABASE_URL を設定
   pnpm drizzle:push
   pnpm dev
   ```
2. Vercel：

   * 新規プロジェクト → リポジトリ接続
   * `NEON_DATABASE_URL` を環境変数に設定
   * ビルド後にそのまま稼働

---

## 命名とブランディング

* プロジェクト名（仮）：**Kakeizu Flow**（変更可）
* ロゴ/アイコンは簡易なテキストロゴで OK（任意）。

---

## 品質チェック（完了条件）

* 初回アクセスでデモツリー作成→自動整列→人物編集→CSV/JSON エクスポート→JSON インポート復元→`/print` で PDF 化まで動作確認済み。
* 主要操作が 3 クリック以内で到達。
* 関係の不整合（自己参照、循環親子）が API レイヤで防止される。

---

以上に従い、**完成コード一式**を生成してください。必要に応じて補助的なファイル（型、ユーティリティ、テストの雛形、サンプルデータ）も作成してください。
